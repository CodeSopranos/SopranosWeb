Что нужно знать про MVC (Model-View-Controller), вкратце:
---------------------------------------------------------

Это не столько конкретный шаблон проектирования, сколько общая архитектурная идея о разделении приложения на логически-независимые компоненты:

* Model: модель предметной области, она же модель домена - набор ключевых абстракций предметной области, описывающих данные, с которыми мы работаем, и их программную реализацию. У нас в приложении модели лежат в модуле models.py, и представляют из себя классы, наследующие от django.db.models.Model. Они связаны с базой данных средствами подсистемы ORM (object-relational mapping), таким образом, что каждой модели соответствует своя таблица с названием <имя_приложения>_<имя_модели>. Это позволяет нам манипулировать объектами модели, в то время как Django транслирует наши манипуляции в соответствующие SQL-запросы к базе.

* View: пользовательское представление данных. Грубо говоря, это пользовательский интерфейс (UI). В нашем случае это HTML, который мы отправляем по запросу. Когда освоим генерацию страниц по шаблону, это будет видно более наглядно.

* Controller: бизнес-логика приложения. В Django контроллеры называются view (да, путаница!) и живут, соответственно, в модуле views.py. Могут представлять из себя либо функции, либо классы. Мы используем функции. get_blog(), get_all_blogs() -- это и есть наши контроллеры.

Начало разработки приложения:
-----------------------------

1. python3 manage.py startapp blogger

2. blogger/models.py

from django.db.models import *

class Blog(Model):
    title = CharField(max_length=80)
    created_at = DateTimeField('creation timestamp', auto_now_add=True)

class Post(Model):
    blog = ForeignKey(Blog, on_delete=CASCADE)
    subject = CharField(max_length=80)
    text = TextField(max_length=4096)
    created_at = DateTimeField('creation timestamp', auto_now_add=True)
    updated_at = DateTimeField('update timestamp', auto_now=True)

3. siteroot/settings.py
В переменной INSTALLED_APPS добавить в список строку 'blogger.apps.BloggerConfig'

4. Миграции
Представляют из себя скрипты специального вида, лежащие в папке blogger/migrations. Каждый скрипт соответствует атомарному изменению структуры базы данных, т.е. структуры модели. После добавления или изменения моделей, нужно сгенерировать миграцию и применить её.

Сгенерировать миграции: python3 manage.py makemigrations blogger
Проверить SQL, не применяя миграцию: python3 manage.py sqlmigrate blogger 0001
Применить все новые миграции: python3 manage.py migrate
Применить конкретную миграцию: python3 manage.py migrate blogger 0001
(последний вариант также можно использовать для отката назад на предыдущую миграцию)
Проверить, что всё в порядке с настройками проекта: python3 manage.py check

Также можно смотреть результат применения миграций непосредственно в БД. Для этого в psql:
\d                      // показать список всех объектов БД
\d blogger_blog         // показать описание конкретного объекта (в данном случае, таблицы)

5. python3 manage.py shell
Один из способов взаимодействия с Django-проектом, через интерактивный интерпретатор питона. Удобно, когда нужно быстро проверить какие-то функции, без внесения изменений в основной код. Например, работу с моделями:

from bloghost.models import *

b = Blog(title='Hi')             # содаём новый объект типа Blog. на данном этапе его ещё нет в базе!
b.save()                         # сохраняем вновь созданный объект. теперь ему соответствует запись в таблице
Blog.objects.all()               # получить список всех объектов типа Blog
b = Blog.objects.get(title='Hi') # получить объект типа Blog, у которого поле title имеет значение 'Hi' (и положить его в переменную b)
b                                # вывести содержимое переменной b. чтобы получить более удобочитаемое представление, нужно добавить в модель функцию __str__(), см. далее
Blog.objects.get(id=1)           # получить объект типа Blog с идентификатором, равным 1 (и вывести его сразу)
Blog.objects.filter(title__startswith='H') # получить все объекты типа Blog, у которых значение поля title начинается на 'H'
b.post_set.all()                 # Получить список всех объектов типа Post, принадлежащих объекту Blog (который находится в переменной b)
b.post_set.create(subject='Hi there', text='First post') # создать новый пост в данном блоге (который по-прежнему лежит в b). запись будет создана сразу!
p = b.post_set.get(id=1)         # получить объект Post, принадлежащий блогу b и имеющий идентификатор, равный 1 (и положить его в переменную p)
p.delete()                       # удалить объект Post, лежащий в переменной p
... и так далее...
более подробно про поддерживаемые запросы можно почитать здесь: https://docs.djangoproject.com/en/3.0/topics/db/queries/ 

6. добавим вывод отладочной строки для наших моделей:

В класс Blog:
    def __str__(self):
        return str(self.title)

В класс Post:
    def __str__(self):
        return str(self.subject)
